package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/http/pprof"
	"os"
	"os/signal"
	"sort"
	"syscall"
	"time"
	"math/rand"
	"strconv"

	fb_flaki "github.com/cloudtrust/elasticsearch-bridge/api/fb"
	internal "github.com/cloudtrust/elasticsearch-bridge/internal/elasticsearch_bridge"
	health2 "github.com/cloudtrust/common-healthcheck"
	health "github.com/cloudtrust/elasticsearch-bridge/pkg/health" 
	"github.com/coreos/go-systemd/dbus"
	"github.com/garyburd/redigo/redis"
	sentry "github.com/getsentry/raven-go"
	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/log"
	"github.com/go-kit/kit/metrics"
	gokit_influx "github.com/go-kit/kit/metrics/influx"
	flatbuffers "github.com/google/flatbuffers/go"
	"github.com/gorilla/mux"
	influx "github.com/influxdata/influxdb/client/v2"
	_ "github.com/lib/pq"
	opentracing "github.com/opentracing/opentracing-go"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	jaeger "github.com/uber/jaeger-client-go/config"
	"google.golang.org/grpc"
)

var (
	// ComponentName is the name of the component.
	ComponentName = "elasticsearch-bridge"
	// ComponentID is an unique ID generated by Flaki at component startup.
	ComponentID = ""
	// Version of the component.
	Version = "1.0"
	// Environment is filled by the compiler.
	Environment = "unknown"
	// GitCommit is filled by the compiler.
	GitCommit = "unknown"
)

func main() {

	// Logger.
	var logger = log.NewJSONLogger(os.Stdout)
	{
		logger = log.With(logger, "ts", log.DefaultTimestampUTC, "caller", log.DefaultCaller)
	}
	defer logger.Log("msg", "goodbye")

	// Configurations.
	var config = config(log.With(logger, "unit", "config"))
	var (
		// Component
		httpAddr = config["component-http-host-port"].(string)

		// Flaki
		flakiAddr      = config["flaki-host-port"].(string)

		// Enabled units
		cockroachEnabled  = config["cockroach"].(bool)
		influxEnabled     = config["influx"].(bool)
		jaegerEnabled     = config["jaeger"].(bool)
		redisEnabled      = config["redis"].(bool)
		sentryEnabled     = config["sentry"].(bool)
		pprofRouteEnabled = config["pprof-route-enabled"].(bool)

		// Influx
		influxHTTPConfig = influx.HTTPConfig{
			Addr:     fmt.Sprintf("http://%s", config["influx-host-port"].(string)),
			Username: config["influx-username"].(string),
			Password: config["influx-password"].(string),
		}
		influxBatchPointsConfig = influx.BatchPointsConfig{
			Precision:        config["influx-precision"].(string),
			Database:         config["influx-database"].(string),
			RetentionPolicy:  config["influx-retention-policy"].(string),
			WriteConsistency: config["influx-write-consistency"].(string),
		}
		influxWriteInterval = time.Duration(config["influx-write-interval-ms"].(int)) * time.Millisecond

		// Jaeger
		jaegerConfig = jaeger.Configuration{
			Disabled: !jaegerEnabled,
			Sampler: &jaeger.SamplerConfig{
				Type:              config["jaeger-sampler-type"].(string),
				Param:             float64(config["jaeger-sampler-param"].(int)),
				SamplingServerURL: fmt.Sprintf("http://%s", config["jaeger-sampler-host-port"].(string)),
			},
			Reporter: &jaeger.ReporterConfig{
				LogSpans:            config["jaeger-reporter-logspan"].(bool),
				BufferFlushInterval: time.Duration(config["jaeger-write-interval-ms"].(int)) * time.Millisecond,
			},
		}
		jaegerCollectorHealthcheckURL = config["jaeger-collector-healthcheck-host-port"].(string)

		// Sentry
		sentryDSN = fmt.Sprintf(config["sentry-dsn"].(string))

		// Redis
		redisURL           = config["redis-host-port"].(string)
		redisPassword      = config["redis-password"].(string)
		redisDatabase      = config["redis-database"].(int)
		redisWriteInterval = time.Duration(config["redis-write-interval-ms"].(int)) * time.Millisecond

		// Cockroach
		cockroachHostPort = config["cockroach-host-port"].(string)
		cockroachUsername = config["cockroach-username"].(string)
		cockroachPassword = config["cockroach-password"].(string)
		cockroachDB       = config["cockroach-database"].(string)
	)

	// Redis.
	type Redis interface {
		Close() error
		Do(commandName string, args ...interface{}) (reply interface{}, err error)
		Send(commandName string, args ...interface{}) error
		Flush() error
	}

	var redisClient Redis
	if redisEnabled {
		var err error
		redisClient, err = redis.Dial("tcp", redisURL, redis.DialDatabase(redisDatabase), redis.DialPassword(redisPassword))
		if err != nil {
			logger.Log("msg", "could not create redis client", "error", err)
			return
		}
		defer redisClient.Close()

		// Create logger that duplicates logs to stdout and Redis.
		logger = log.NewJSONLogger(io.MultiWriter(os.Stdout, internal.NewLogstashRedisWriter(redisClient, ComponentName)))
		logger = log.With(logger, "ts", log.DefaultTimestampUTC, "caller", log.DefaultCaller)
	} else {
		redisClient = &internal.NoopRedis{}
	}

	// Flaki.
	var flakiClient fb_flaki.FlakiClient
	{
		// Set up a connection to the flaki-service.
		var conn *grpc.ClientConn
		{
			var err error
			conn, err = grpc.Dial(flakiAddr, grpc.WithInsecure(), grpc.WithCodec(flatbuffers.FlatbuffersCodec{}))
			if err != nil {
				logger.Log("msg", "could not connect to flaki-service", "error", err)
				return
			}
			defer conn.Close()
		}

		flakiClient = fb_flaki.NewFlakiClient(conn)
	}

	// Get unique ID for this component
	// Flaki request
	var b = flatbuffers.NewBuilder(0)
	fb_flaki.FlakiRequestStart(b)
	b.Finish(fb_flaki.FlakiRequestEnd(b))

	var reply, err = flakiClient.NextValidID(ctx, b)

	// If we cannot get ID from Flaki, we generate a random one.
	if err != nil {
		rand.Seed(time.Now().UnixNano())
		ComponentID = "degredaded-" + strconv.FormatUint(rand.Uint64(), 10)
	} else {
		ComponentID = string(reply.Id())
	}

	// Add component name, component ID and version to the logger tags.
	logger = log.With(logger, "component_name", ComponentName, "component_id", ComponentID, "component_version", Version)

	// Log component version infos.
	logger.Log("environment", Environment, "git_commit", GitCommit)

	// Critical errors channel.
	var errc = make(chan error)
	go func() {
		var c = make(chan os.Signal, 1)
		signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
		errc <- fmt.Errorf("%s", <-c)
	}()

	// Sentry.
	type Sentry interface {
		CaptureError(err error, tags map[string]string, interfaces ...sentry.Interface) string
		URL() string
		Close()
	}

	var sentryClient Sentry
	if sentryEnabled {
		var logger = log.With(logger, "unit", "sentry")
		var err error
		sentryClient, err = sentry.New(sentryDSN)
		if err != nil {
			logger.Log("msg", "could not create Sentry client", "error", err)
			return
		}
		defer sentryClient.Close()
	} else {
		sentryClient = &internal.NoopSentry{}
	}

	// Influx client.
	type Metrics interface {
		NewCounter(name string) metrics.Counter
		NewGauge(name string) metrics.Gauge
		NewHistogram(name string) metrics.Histogram
		WriteLoop(c <-chan time.Time)
		Ping(timeout time.Duration) (time.Duration, string, error)
	}

	var influxMetrics Metrics
	if influxEnabled {
		var logger = log.With(logger, "unit", "influx")

		var influxClient, err = influx.NewHTTPClient(influxHTTPConfig)
		if err != nil {
			logger.Log("msg", "could not create Influx client", "error", err)
			return
		}
		defer influxClient.Close()

		var gokitInflux = gokit_influx.New(
			map[string]string{},
			influxBatchPointsConfig,
			log.With(logger, "unit", "go-kit influx"),
		)

		influxMetrics = internal.NewMetrics(influxClient, gokitInflux)
	} else {
		influxMetrics = &internal.NoopMetrics{}
	}

	// Jaeger client.
	var tracer opentracing.Tracer
	{
		var logger = log.With(logger, "unit", "jaeger")
		var closer io.Closer
		var err error

		tracer, closer, err = jaegerConfig.New(ComponentName)
		if err != nil {
			logger.Log("msg", "could not create Jaeger tracer", "error", err)
			return
		}
		defer closer.Close()
	}

	// Systemd D-Bus connection.
	var systemDConn *dbus.Conn
	{
		var err error
		systemDConn, err = dbus.New()
		if err != nil {
			logger.Log("msg", "could not create systemd D-Bus connection", "error", err)
			return
		}
	}

	// Cockroach DB.
	type Cockroach interface {
		Exec(query string, args ...interface{}) (sql.Result, error)
		QueryRow(query string, args ...interface{}) *sql.Row
	}

	var cockroachConn Cockroach
	if cockroachEnabled {
		var err error
		cockroachConn, err = sql.Open("postgres", fmt.Sprintf("postgresql://%s:%s@%s/%s?sslmode=disable", cockroachUsername, cockroachPassword, cockroachHostPort, cockroachDB))
		if err != nil {
			logger.Log("msg", "could not create cockroach DB connection for health DB", "error", err)
			return
		}
	} else { 
		cockroachConn = nil
	}

	// Job service
	{

	}
 

	// Health service.
	var healthLogger = log.With(logger, "svc", "health")

	var cockroachModule health.StorageModule
	{ 
		cockroachModule = health.NewCockroachModule(cockroachConn)
	}

	var healthComponent health.HealthChecker 
	{
		var influxHM health2.InfluxHealthChecker = health2.NewInfluxModule(influxMetrics, influxEnabled)
		influxHM = health2.MakeInfluxModuleLoggingMW(log.With(healthLogger, "mw", "module"))(influxHM)

		var jaegerHM health.JaegerHealthChecker = health.NewJaegerModule(systemDConn, http.DefaultClient, jaegerCollectorHealthcheckURL, jaegerEnabled)
		jaegerHM = health.MakeJaegerModuleLoggingMW(log.With(healthLogger, "mw", "module"))(jaegerHM)

		var redisHM health.RedisHealthChecker = health.NewRedisModule(redisClient, redisEnabled)
		redisHM = health.MakeRedisModuleLoggingMW(log.With(healthLogger, "mw", "module"))(redisHM)

		var sentryHM health.SentryHealthChecker = health.NewSentryModule(sentryClient, http.DefaultClient, sentryEnabled)
		sentryHM = health.MakeSentryModuleLoggingMW(log.With(healthLogger, "mw", "module"))(sentryHM)

		healthComponent = health.NewComponent(influxHM, jaegerHM, redisHM, sentryHM, cockroachModule)
		healthComponent = health.MakeComponentLoggingMW(log.With(healthLogger, "mw", "component"))(healthComponent)
		var influxExecHealthEndpoint endpoint.Endpoint
	}

	{
		influxExecHealthEndpoint = health.MakeExecInfluxHealthCheckEndpoint(healthComponent)
		influxExecHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "ExecInfluxHealthCheck"))(influxExecHealthEndpoint)
		influxExecHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(influxExecHealthEndpoint)
	}
	var influxReadHealthEndpoint endpoint.Endpoint
	{
		influxReadHealthEndpoint = health.MakeReadInfluxHealthCheckEndpoint(healthComponent)
		influxReadHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "ReadInfluxHealthCheck"))(influxReadHealthEndpoint)
		influxReadHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(influxReadHealthEndpoint)
	}
	var jaegerExecHealthEndpoint endpoint.Endpoint
	{
		jaegerExecHealthEndpoint = health.MakeExecJaegerHealthCheckEndpoint(healthComponent)
		jaegerExecHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "ExecJaegerHealthCheck"))(jaegerExecHealthEndpoint)
		jaegerExecHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(jaegerExecHealthEndpoint)
	}
	var jaegerReadHealthEndpoint endpoint.Endpoint
	{
		jaegerReadHealthEndpoint = health.MakeReadJaegerHealthCheckEndpoint(healthComponent)
		jaegerReadHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "ReadJaegerHealthCheck"))(jaegerReadHealthEndpoint)
		jaegerReadHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(jaegerReadHealthEndpoint)
	}
	var redisExecHealthEndpoint endpoint.Endpoint
	{
		redisExecHealthEndpoint = health.MakeExecRedisHealthCheckEndpoint(healthComponent)
		redisExecHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "ExecRedisHealthCheck"))(redisExecHealthEndpoint)
		redisExecHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(redisExecHealthEndpoint)
	}
	var redisReadHealthEndpoint endpoint.Endpoint
	{
		redisReadHealthEndpoint = health.MakeReadRedisHealthCheckEndpoint(healthComponent)
		redisReadHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "ReadRedisHealthCheck"))(redisReadHealthEndpoint)
		redisReadHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(redisReadHealthEndpoint)
	}
	var sentryExecHealthEndpoint endpoint.Endpoint
	{
		sentryExecHealthEndpoint = health.MakeExecSentryHealthCheckEndpoint(healthComponent)
		sentryExecHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "ExecSentryHealthCheck"))(sentryExecHealthEndpoint)
		sentryExecHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(sentryExecHealthEndpoint)
	}
	var sentryReadHealthEndpoint endpoint.Endpoint
	{
		sentryReadHealthEndpoint = health.MakeReadSentryHealthCheckEndpoint(healthComponent)
		sentryReadHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "ReadSentryHealthCheck"))(sentryReadHealthEndpoint)
		sentryReadHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(sentryReadHealthEndpoint)
	}
	var allHealthEndpoint endpoint.Endpoint
	{
		allHealthEndpoint = health.MakeAllHealthChecksEndpoint(healthComponent)
		allHealthEndpoint = health.MakeEndpointLoggingMW(log.With(healthLogger, "mw", "endpoint", "unit", "AllHealthCheck"))(allHealthEndpoint)
		allHealthEndpoint = health.MakeEndpointCorrelationIDMW(flakiModule)(allHealthEndpoint)
	}

	var healthEndpoints = health.Endpoints{
		InfluxExecHealthCheck: influxExecHealthEndpoint,
		InfluxReadHealthCheck: influxReadHealthEndpoint,
		JaegerExecHealthCheck: jaegerExecHealthEndpoint,
		JaegerReadHealthCheck: jaegerReadHealthEndpoint,
		RedisExecHealthCheck:  redisExecHealthEndpoint,
		RedisReadHealthCheck:  redisReadHealthEndpoint,
		SentryExecHealthCheck: sentryExecHealthEndpoint,
		SentryReadHealthCheck: sentryReadHealthEndpoint,
		AllHealthChecks:       allHealthEndpoint,
	}


	// HTTP server.
	go func() {
		var logger = log.With(logger, "transport", "http")
		logger.Log("addr", httpAddr)

		var route = mux.NewRouter()

		// Version.
		route.Handle("/", http.HandlerFunc(makeVersion(ComponentName, ComponentID, Version, Environment, GitCommit)))

		// Health checks.
		var healthSubroute = route.PathPrefix("/health").Subrouter()

		var allHealthChecksHandler = health.MakeAllHealthChecksHandler(healthEndpoints.AllHealthChecks)
		healthSubroute.Handle("", allHealthChecksHandler)

		healthSubroute.Handle("/influx", health.MakeInfluxHealthCheckGETHandler(healthEndpoints.InfluxReadHealthCheck)).Methods("GET")
		healthSubroute.Handle("/influx", health.MakeInfluxHealthCheckPOSTHandler(healthEndpoints.InfluxExecHealthCheck)).Methods("POST")

		healthSubroute.Handle("/jaeger", health.MakeJaegerHealthCheckGETHandler(healthEndpoints.JaegerReadHealthCheck)).Methods("GET")
		healthSubroute.Handle("/jaeger", health.MakeJaegerHealthCheckPOSTHandler(healthEndpoints.JaegerExecHealthCheck)).Methods("POST")

		healthSubroute.Handle("/redis", health.MakeRedisHealthCheckGETHandler(healthEndpoints.RedisReadHealthCheck)).Methods("GET")
		healthSubroute.Handle("/redis", health.MakeRedisHealthCheckPOSTHandler(healthEndpoints.RedisExecHealthCheck)).Methods("POST")

		healthSubroute.Handle("/sentry", health.MakeSentryHealthCheckGETHandler(healthEndpoints.SentryReadHealthCheck)).Methods("GET")
		healthSubroute.Handle("/sentry", health.MakeSentryHealthCheckPOSTHandler(healthEndpoints.SentryExecHealthCheck)).Methods("POST")

		// Debug.
		if pprofRouteEnabled {
			var debugSubroute = route.PathPrefix("/debug").Subrouter()
			debugSubroute.HandleFunc("/pprof/", http.HandlerFunc(pprof.Index))
			debugSubroute.HandleFunc("/pprof/cmdline", http.HandlerFunc(pprof.Cmdline))
			debugSubroute.HandleFunc("/pprof/profile", http.HandlerFunc(pprof.Profile))
			debugSubroute.HandleFunc("/pprof/symbol", http.HandlerFunc(pprof.Symbol))
			debugSubroute.HandleFunc("/pprof/trace", http.HandlerFunc(pprof.Trace))
		}

		errc <- http.ListenAndServe(httpAddr, route)
	}()

	// Influx writing.
	go func() {
		var tic = time.NewTicker(influxWriteInterval)
		defer tic.Stop()
		influxMetrics.WriteLoop(tic.C)
	}()

	// Redis writing.
	if redisEnabled {
		go func() {
			var tic = time.NewTicker(redisWriteInterval)
			defer tic.Stop()
			for range tic.C {
				redisClient.Flush()
			}
		}()
	}
	logger.Log("error", <-errc)
}

type info struct {
	Name    string `json:"name"`
	ID      string `json:"id"`
	Version string `json:"version"`
	Env     string `json:"environment"`
	Commit  string `json:"commit"`
}

// makeVersion makes a HTTP handler that returns information about the version of the service.
func makeVersion(componentName, componentID, version, environment, gitCommit string) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json; charset=utf-8")

		var infos = info{
			Name:    componentName,
			ID:      componentID,
			Version: version,
			Env:     environment,
			Commit:  gitCommit,
		}

		var j, err = json.MarshalIndent(infos, "", "  ")
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
		} else {
			w.WriteHeader(http.StatusOK)
			w.Write(j)
		}
	}
}

func config(logger log.Logger) map[string]interface{} {
	logger.Log("msg", "load configuration and command args")

	// Component default.
	viper.SetDefault("config-file", "./configs/flakid.yml")
	viper.SetDefault("component-http-host-port", "0.0.0.0:8888")
	viper.SetDefault("component-grpc-host-port", "0.0.0.0:5555")

	// Flaki generator default.
	viper.SetDefault("flaki-host-port", "")

	// Influx DB client default.
	viper.SetDefault("influx", false)
	viper.SetDefault("influx-host-port", "")
	viper.SetDefault("influx-username", "")
	viper.SetDefault("influx-password", "")
	viper.SetDefault("influx-database", "")
	viper.SetDefault("influx-precision", "")
	viper.SetDefault("influx-retention-policy", "")
	viper.SetDefault("influx-write-consistency", "")
	viper.SetDefault("influx-write-interval-ms", 1000)

	// Sentry client default.
	viper.SetDefault("sentry", false)
	viper.SetDefault("sentry-dsn", "")

	// Jaeger tracing default.
	viper.SetDefault("jaeger", false)
	viper.SetDefault("jaeger-sampler-type", "")
	viper.SetDefault("jaeger-sampler-param", 0)
	viper.SetDefault("jaeger-sampler-host-port", "")
	viper.SetDefault("jaeger-reporter-logspan", false)
	viper.SetDefault("jaeger-write-interval-ms", 1000)
	viper.SetDefault("jaeger-collector-healthcheck-host-port", "")

	// Debug routes enabled.
	viper.SetDefault("pprof-route-enabled", true)

	// Redis.
	viper.SetDefault("redis", false)
	viper.SetDefault("redis-host-port", "")
	viper.SetDefault("redis-password", "")
	viper.SetDefault("redis-database", 0)
	viper.SetDefault("redis-write-interval-ms", 1000)

	// Cockroach.
	viper.SetDefault("cockroach", false)
	viper.SetDefault("cockroach-host-port", "")
	viper.SetDefault("cockroach-username", "")
	viper.SetDefault("cockroach-password", "")
	viper.SetDefault("cockroach-database", "")

	// First level of override.
	pflag.String("config-file", viper.GetString("config-file"), "The configuration file path can be relative or absolute.")
	viper.BindPFlag("config-file", pflag.Lookup("config-file"))
	pflag.Parse()

	// Load config.
	viper.SetConfigFile(viper.GetString("config-file"))
	var err = viper.ReadInConfig()
	if err != nil {
		logger.Log("error", err)
	}
	var config = viper.AllSettings()

	// If the host/port is not set, we consider the components deactivated.
	config["influx"] = config["influx-host-port"].(string) != ""
	config["sentry"] = config["sentry-dsn"].(string) != ""
	config["jaeger"] = config["jaeger-sampler-host-port"].(string) != ""
	config["redis"] = config["redis-host-port"].(string) != ""
	config["cockroach"] = config["cockroach-host-port"].(string) != ""

	// Log config in alphabetical order.
	var keys []string
	for k := range config {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		logger.Log(k, config[k])
	}

	return config
}
